Лабораторная №3 по теме "Фильтруемый список в React"
Продолжаем разработку в духе TDD: вначале пишем тесты, потом пишем компонент, который проходит тесты.
Задание 1
Каждый элемент списка должен обладать контролируемым чекбоксом. При изменении состояния чекбокса нужно сохранять актуальное значение в том же стейте, где лежит список дел.

Задание 2
Осуществить фильтрацию списка в соответствии со значением чекбокса "Только выполненные".

Задание 3 [опционально]
Выделить стор в отдельный файл. В нём сделать функцию reducer, принимающую на вход действие (action) и предыдущее состояние стора, и выдающую новое состояние стора.

Традиционный формат объекта action: поле type характеризует, что надо делать; поле payload содержит полезную нагрузку.

Для стора надо написать вначале тесты, потом реализовывать сам стор.

Фильтрующая функция тоже должна жить в сторе. Такие функции традиционно называются селекторы.

Разработка через TDD
Требования к компонентам:

ListItem
Должен отображает на экране то, что передали в пропсе title.
Должен показывать на экране кнопку.
При нажатии на кнопку должен вызываться переданный в пропсах коллбэк handleDelete.
Коллбэк должен вызываться с параметром id, который мы передаём в компонент.
Должен показывать на экране чекбокс.
Состояние чекбокса зависит от переданного пропса checked.
При клике на чекбокс должен вызываться переданный в пропсах коллбэк handleChecked.
Коллбэк должен вызываться с параметром id, который мы передаём в компонент.
List
Позитивный кейс: отображение непустого списка:
Компонент выводит каждый элемент списка.
Кнопка в каждом элементе нажимается, при этом вызывается handleDelete с параметром id.
Чекбокс в каждом элементе прокликивается, при этом вызывается handleChecked с параметром id.
Негативный кейс: отображение пустого списка:
Выводится надпись "В списке нет элементов".
Form
Отображается поле для ввода и кнопка "Добавить".
Можно ввести что-то в поле для ввода.
При нажатии на кнопку вызывается handleSubmit с параметром, равным тому, что ввели в поле для ввода.
Store [опционально]
При вызове редьюсера с экшеном add возвращается состояние стора, в котором добавлен новый элемент.
При вызове редьюсера с экшеном delete возвращается состояние стора, в котором удалён указанный элемент.
При вызове редьюсера с экшеном check возвращается состояние стора, в котором состояние указанного элемента изменено.
export const ACTION_TYPES = {
    ADD: 'add',
    /* тут ещё варианты */
};

export const initialState = [];

export function reducer(action, prevState = initialState) {
    switch (action.type) {
        case ACTION_TYPES.DELETE: {
            return [...prevState.filter(item => item.id !== action.payload)];
        }
        /* тут ещё варианты */
        default: return [...prevState];
    }
}

export function selectFilteredList({list, isDone}) {
    if (!isDone) return list;

    return list.filter(element => element.isChecked);
}

// в App.jsx:
  function dispatch(action) {
    setList(reducer(action, list));
  }
// ...
      <List
        list={selectFilteredList({list, isDone})}
        dispatch={dispatch}/>

// в Item.jsx:
        <button onClick={() => dispatch({type: ACTION_TYPES.DELETE, payload: id})}>
            [x]
        </button>
Способ выполнения
Сделать форк этого репозитория.
Разработку вести через TDD: вначале тесты, потом компонент.
Решение без тестов приниматься не будет.
Результат оформить в виде pull request.
Запуск
npm i
npm start
Запуск тестов
npm run test